# 领域管理（Managing domains）

在前面的章节中，我们讨论了领域的核心构建块：`dto`、`动作（actions）`、`模型（models）` 和几个相关的概念。在本章中，我们将把重点从技术方面转移到哲学方面：如何开始使用领域，如何识别它们，以及如何长期管理它们?

## 团队协作（Teamwork）

回到第一章，我说过我所写的所有范例和原则都有一个目的：帮助开发团队保持他们的大型 Laravel 应用程序的可维护性。

在写这本书和之前的博客文章时，一些人表达了他们的担忧：新的目录结构和复杂规则的使用会不会让新开发人员很难立马上手？

如果你是一个熟悉默认 Laravel 项目结构的开发人员，并且熟悉 Laravel 向初学者输出的思想，那么你确实需要花一些时间来学习这些项目是如何处理的。但是，这并不像有些人想的那样需要大动干戈。

想象一个项目有大约 100 个模型（models），300 个动作（actions），近 500 条路由。这些项目的主要困难不在于代码的技术结构；相反，是因为那些需要去了解的大量商业知识。您不能期望新的开发人员能够立即理解这个项目正在解决的所有问题。了解代码需要时间，但更重要的是：了解业务也需要时间。魔术方法和间接手段越少，混乱的地方就越少。

理解我在本书中展开的体系结构的目的是必要的。它不是关于如何写最少的代码或者最优雅的代码。它是关于使大型代码库更容易浏览，尽量减少混乱的地方，并保持项目长期健康。

我对这个过程有实践经验。我的同事 Ruben 在我们的一个项目中作为一个新的后端开发人员，加入了一个由三个开发人员组成的团队。

这个架构对他来说是新的，即使他以前有使用 Laravel 的经验。所以我们花时间来指导他。仅仅经过几个小时的介绍和结对编程（pair programming），他就能够独立完成这个项目。这肯定需要几个星期的时间来彻底了解这个项目所提供的所有功能，但幸运的是，架构并没有难倒他。相反，它让 Ruben 更专注于业务逻辑。

如果你能坚持到本书的这一步，我希望你能明白，这种架构并不是要成为每个项目的银弹。在很多情况下，更直接的方法可以更好地工作，而在某些情况下，需要更复杂的方法。

## 识别领域（Identifying domains）

随着我们现在对基本领域构建块的了解，问题出现了：我们如何准确地开始编写实际的代码。你可以使用许多方法去更好地理解你将要构建的内容，尽管我认为其中有两个关键点:

- 即使您是一名开发人员，您的主要目标也是理解业务问题并将其转换为代码。代码本身只是达到目的的一种手段；永远把你的注意力放在你正在解决的问题上。
- 确保你有和客户面对面的时间。你需要花时间去获取编程所需要的相关知识。

实际上，我认为我的工作描述更像是『现实问题和技术解决方案之间的翻译』，而不是『一个编写代码的程序员』。我坚信，如果你打算在一个长期运行的项目工作，这种心态是非常关键的。你不只是要写代码 —— 你需要理解你要解决的现实世界的问题。

根据你的团队的规模，你可能不需要所有的开发人员和客户之间进行面对面的互动，但尽管如此，所有的开发人员都需要了解他们正在用代码解决的问题。

团队动态是一个如此复杂的话题，以至于它们应该有自己的书。现在我就保持这个状态，因为从这里开始我们可以讨论如何将这些问题转化为领域。

在第一章中，我写道，这个架构的目标之一是将代码根据它们在现实世界中的意义进行分组，而不是根据技术属性分组。如果你和你的客户放开沟通，你会注意到那会花时间 —— 大量的时间 —— 来对他们的业务有一个好的了解。通常你的客户可能自己也不清楚，只有坐下来才开始彻底思考。

在第一章中，我写道，这个架构的目标之一是根据它们在现实世界中的意义而不是技术属性，将属于它们的代码分组。如果你和你的客户有一个开放的沟通，你会注意到那很费时间--很多时间--来对他们的业务有一个好的了解。通常你的客户可能自己也不清楚，只有坐下来才开始彻底思考。

这就是为什么你不应该害怕领域会随者时间变化。你可能一开始有一个发票领域（Invoice domain），但半年后发现它已经变得太大，你和你的团队无法完全掌控。也许发票生成和支付是两个独立的复杂系统，所以它们可以被分成两个领域。

我的观点是，不断迭代你的领域结构、不断重构它才能保证它的健康。如果有合适的工具，改变、分割和重构领域一点都不难。


综上所述：不要害怕开始使用领域，因为你以后总是可以重构它们。

因此，如果我想开始使用这种面向领域的架构，我会采取这样的方法：尝试在项目中确定子系统，意识到它们可以 —— 而且会 —— 随着时间的推移而改变。你可以和你的客户坐下来，你可以让他们把事情写下来，你甚至可以和他们做事件风暴会议（do event storming sessions）。你们一起形成一个项目应有的蓝图（image），而这个蓝图（image）很可能会被完善，也会随着时间的推移而改变。

而且，由于我们的领域代码有最小的依赖性，所以它非常灵活，改动或重构的成本不高。

## 测试领域（Testing domains）

到目前为止，我已经解释了领域代码的构成，以及如何在整个时间周期内管理它。但还缺少一个关键的方面：我们将如何测试这一切。我已经在零零碎碎的地方展示了一些测试，并告诉你我们的模块化架构是如何实现简单的单元测试的，但在这一章，我将向你展示测试领域代码的来龙去脉。

但在做这些之前，我还想向你解释一个模式，因为它将使我们的测试容易十倍。让我们来看看工厂模式。

## 测试工厂（Test factories）

你可能已经知道 Laravel 中的测试工厂，它们看起来像这样：

```
factory(Invoice::class)->create();
```

这是一个非常简洁和直接的方法，但它实际上缺乏一些基本功能。事实上，`Laravel 8` 带来了一种新的测试工厂，它将更贴合我今天要描述的模式。

但是在看这个模式之前，让我们先讨论一下在 `Laravel 8` 之前，Laravel 的工厂在哪些方面存在不足。以工厂状态为例，这是一个强大的模式，但在 Laravel 中就是战五渣。

```
$factory->state(Invoice::class, 'pending', [
    'status' => PaidInvoiceState::class,
]);
```

首先，你的 IDE 不知道 `$factory` 究竟是什么样的对象。它神奇地存在于工厂文件中，也没有自动完成的功能。一个快速的解决方案是为它添加 `DocBlock`，然而这很麻烦。

```
/** @var \Illuminate\Database\Eloquent\Factory $factory */
$factory->state(/* ... */);
```

其次，状态被定义为字符串，在测试中使用工厂时，它们是一个黑盒。

```
public function test_case()
{
    $invoice = factory(Invoice::class)
        ->states(/* 这里有哪些可用的状态？ */)
        ->create();
}
```

再者，工厂的结果没有类型提示。你的 IDE 不知道 `$invoice` 实际上是一个 `Invoice` 模型；又是一个黑盒。

```
public function test_case()
{
    $invoice = factory(Invoice::class)->create();

    $invoice->/* ... ?? */;
}
```

接下来，给定一个足够大的领域，你可能在你的测试套件中需要不止几个状态，随着时间的推移这将成为管理它们的挑战。

最后，这些工厂只为我们创建模型。如果我们想在测试中使用 `DTO` 或 `请求（requests）` 怎么办？

因此，我们将看一下工厂模式，并从头开始建立，为我们的测试做准备。它们将会更灵活，并大大改善开发者的体验。这些工厂类的实际目的是帮助你写集成测试（integration tests），并且不需要花太多的时间来系统地配置它。

请注意，我说的是『集成测试（integration tests）』而不是『单元测试（unit tests）』：当我们测试我们的领域代码时，我们是在测试核心业务逻辑。更多的时候，测试这个业务逻辑意味着我们不会测试一个类的孤立片断，而是测试一个复杂的（complex）、错综复杂（intricate）的业务规则，数据需要保存到数据库中。

正如我之前提到的：我们在本书中讨论的是大型复杂系统；记住这一点很重要。特别是，这就是为什么我决定在本章中把这些测试称为集成测试；我想避免讨论什么是单元测试，什么不是。

那么，现在就让我们来看看工厂模式。

## 基本工厂（A basic factory）

A test factory is nothing more than a simple class. There's no package to require, no interfaces to implement or abstract classes to extend. The power of a factory is not the complexity of the code, but rather one or two patterns properly applied.

Here's what such a class looks like, simplified:

```
class InvoiceFactory
{
    public static function new(): self
    {
        return new self();
    }

    public function create(array $extra = []): Invoice
    {
        return Invoice::create(array_merge(
            [
                'number' => 'I-1',
                'status' => PendingInvoiceState::class,
                // ...
            ],
            $extra
        ));
    }
}
```

Let's discuss a few design decisions.

First of all, the static constructor new. You might be confused as to why we need it, as we could simply make the create method static. I'll answer that question in depth later in this chapter, but now, you should know that we want this factory to be highly configurable before actually creating an invoice. So rest assured, it will become clear soon.

Secondly, why the name new for the static constructor? The answer is a practical one: within the context of factories, make and create are often associated with a factory actually producing a result. new helps us avoid unnecessary confusion.

Finally, the create method: it takes an optional array of extra data to ensure we can always make some last-minute changes in our tests.

With our simple example, we can now create invoices like so:

```
public function test_case()
{
    $invoice = InvoiceFactory::new()->create();
}
```

Before looking at configurability, let's address a little improvement we can make right away: invoice numbers should be unique, so if we create two invoices in one test case, it will break. We don't want to worry about keeping track of invoice numbers in most cases, so let's have the factory take care of those:

```
class InvoiceFactory
{
    private static int $number = 0;

    public function create(array $extra = []): Invoice
    {
        self::$number += 1;

        return Invoice::create(array_merge(
            [
                'number' => 'I-' . self::$number,
                // ...
            ],
            $extra
        ));
    }
}
```

## 工厂嵌套（Factories in factories）























