# 测试领域（Testing domains）

到目前为止，我已经解释了领域代码的构成，以及如何在整个时间周期内管理它。但还缺少一个关键的方面：我们将如何测试这一切。我已经在零零碎碎的地方展示了一些测试，并告诉你我们的模块化架构是如何实现简单的单元测试的，但在这一章，我将向你展示测试领域代码的来龙去脉。

但在做这些之前，我还想向你解释一个模式，因为它将使我们的测试容易十倍。让我们来看看工厂模式。

## 测试工厂（Test factories）

你可能已经知道 Laravel 中的测试工厂，它们看起来像这样：

```
factory(Invoice::class)->create();
```

这是一个非常简洁和直接的方法，但它实际上缺乏一些基本功能。事实上，`Laravel 8` 带来了一种新的测试工厂，它将更贴合我今天要描述的模式。

但是在看这个模式之前，让我们先讨论一下在 `Laravel 8` 之前，Laravel 的工厂在哪些方面存在不足。以工厂状态为例，这是一个强大的模式，但在 Laravel 中就是战五渣。

```
$factory->state(Invoice::class, 'pending', [
    'status' => PaidInvoiceState::class,
]);
```

首先，你的 IDE 不知道 `$factory` 究竟是什么样的对象。它神奇地存在于工厂文件中，也没有自动完成的功能。一个快速的解决方案是为它添加 `DocBlock`，然而这很麻烦。

```
/** @var \Illuminate\Database\Eloquent\Factory $factory */
$factory->state(/* ... */);
```

其次，状态被定义为字符串，在测试中使用工厂时，它们是一个黑盒。

```
public function test_case()
{
    $invoice = factory(Invoice::class)
        ->states(/* 这里有哪些可用的状态？ */)
        ->create();
}
```

再者，工厂的结果没有类型提示。你的 IDE 不知道 `$invoice` 实际上是一个 `Invoice` 模型；又是一个黑盒。

```
public function test_case()
{
    $invoice = factory(Invoice::class)->create();

    $invoice->/* ... ?? */;
}
```

接下来，给定一个足够大的领域，你可能在你的测试套件中需要不止几个状态，随着时间的推移这将成为管理它们的挑战。

最后，这些工厂只为我们创建模型。如果我们想在测试中使用 `DTO` 或 `请求（requests）` 怎么办？

因此，我们将看一下工厂模式，并从头开始建立，为我们的测试做准备。它们将会更灵活，并大大改善开发者的体验。这些工厂类的实际目的是帮助你写集成测试（integration tests），并且不需要花太多的时间来系统地配置它。

请注意，我说的是『集成测试（integration tests）』而不是『单元测试（unit tests）』：当我们测试我们的领域代码时，我们是在测试核心业务逻辑。更多的时候，测试这个业务逻辑意味着我们不会测试一个类的孤立片断，而是测试一个复杂的（complex）、错综复杂（intricate）的业务规则，数据需要保存到数据库中。

正如我之前提到的：我们在本书中讨论的是大型复杂系统；记住这一点很重要。特别是，这就是为什么我决定在本章中把这些测试称为集成测试；我想避免讨论什么是单元测试，什么不是。

那么，现在就让我们来看看工厂模式。

## 基本工厂（A basic factory）

测试工厂只不过是一个简单的类。不需要包，不需要实现接口或扩展抽象类。工厂的所带来的能力（power）不是由于它代码的复杂性，而是正确应用的一两个模式。

简化后的类是这样的：

```
class InvoiceFactory
{
    public static function new(): self
    {
        return new self();
    }

    public function create(array $extra = []): Invoice
    {
        return Invoice::create(array_merge(
            [
                'number' => 'I-1',
                'status' => PendingInvoiceState::class,
                // ...
            ],
            $extra
        ));
    }
}
```

让我们讨论一些设计方案（design decisions）。

First of all, the static constructor new. You might be confused as to why we need it, as we could simply make the create method static. I'll answer that question in depth later in this chapter, but now, you should know that we want this factory to be highly configurable before actually creating an invoice. So rest assured, it will become clear soon.

Secondly, why the name new for the static constructor? The answer is a practical one: within the context of factories, make and create are often associated with a factory actually producing a result. new helps us avoid unnecessary confusion.

Finally, the create method: it takes an optional array of extra data to ensure we can always make some last-minute changes in our tests.

With our simple example, we can now create invoices like so:

```
public function test_case()
{
    $invoice = InvoiceFactory::new()->create();
}
```

Before looking at configurability, let's address a little improvement we can make right away: invoice numbers should be unique, so if we create two invoices in one test case, it will break. We don't want to worry about keeping track of invoice numbers in most cases, so let's have the factory take care of those:

```
class InvoiceFactory
{
    private static int $number = 0;

    public function create(array $extra = []): Invoice
    {
        self::$number += 1;

        return Invoice::create(array_merge(
            [
                'number' => 'I-' . self::$number,
                // ...
            ],
            $extra
        ));
    }
}
```

## 工厂嵌套（Factories in factories）
