# 测试领域（Testing domains）

到目前为止，我已经解释了领域代码的构成，以及如何在整个时间周期内管理它。但还缺少一个关键的方面：我们将如何测试这一切。我已经在零零碎碎的地方展示了一些测试，并告诉你我们的模块化架构是如何实现简单的单元测试的，但在这一章，我将向你展示测试领域代码的来龙去脉。

但在做这些之前，我还想向你解释一个模式，因为它将使我们的测试容易十倍。让我们来看看工厂模式。

## 测试工厂（Test factories）

你可能已经知道 Laravel 中的测试工厂，它们看起来像这样：

```
factory(Invoice::class)->create();
```

这是一个非常简洁和直接的方法，但它实际上缺乏一些基本功能。事实上，`Laravel 8` 带来了一种新的测试工厂，它将更贴合我今天要描述的模式。

但是在看这个模式之前，让我们先讨论一下在 `Laravel 8` 之前，Laravel 的工厂在哪些方面存在不足。以工厂状态为例，这是一个强大的模式，但在 Laravel 中就是战五渣。

```
$factory->state(Invoice::class, 'pending', [
    'status' => PaidInvoiceState::class,
]);
```

首先，你的 IDE 不知道 `$factory` 究竟是什么样的对象。它神奇地存在于工厂文件中，也没有自动完成的功能。一个快速的解决方案是为它添加 `DocBlock`，然而这很麻烦。

```
/** @var \Illuminate\Database\Eloquent\Factory $factory */
$factory->state(/* ... */);
```

其次，状态被定义为字符串，在测试中使用工厂时，它们是一个黑盒。

```
public function test_case()
{
    $invoice = factory(Invoice::class)
        ->states(/* 这里有哪些可用的状态？ */)
        ->create();
}
```

再者，工厂的结果没有类型提示。你的 IDE 不知道 `$invoice` 实际上是一个 `Invoice` 模型；又是一个黑盒。

```
public function test_case()
{
    $invoice = factory(Invoice::class)->create();

    $invoice->/* ... ?? */;
}
```

接下来，给定一个足够大的领域，你可能在你的测试套件中需要不止几个状态，随着时间的推移这将成为管理它们的挑战。

最后，这些工厂只为我们创建模型。如果我们想在测试中使用 `DTO` 或 `请求（requests）` 怎么办？

因此，我们将看一下工厂模式，并从头开始建立，为我们的测试做准备。它们将会更灵活，并大大改善开发者的体验。这些工厂类的实际目的是帮助你写集成测试（integration tests），并且不需要花太多的时间来系统地配置它。

请注意，我说的是『集成测试（integration tests）』而不是『单元测试（unit tests）』：当我们测试我们的领域代码时，我们是在测试核心业务逻辑。更多的时候，测试这个业务逻辑意味着我们不会测试一个类的孤立片断，而是测试一个复杂的（complex）、错综复杂（intricate）的业务规则，数据需要保存到数据库中。

正如我之前提到的：我们在本书中讨论的是大型复杂系统；记住这一点很重要。特别是，这就是为什么我决定在本章中把这些测试称为集成测试；我想避免讨论什么是单元测试，什么不是。

那么，现在就让我们来看看工厂模式。

## 基本工厂（A basic factory）

测试工厂只不过是一个简单的类。不需要包，不需要实现接口或扩展抽象类。工厂的所带来的能力（power）不是由于它代码的复杂性，而是正确应用的一两个模式。

简化后的类是这样的：

```
class InvoiceFactory
{
    public static function new(): self
    {
        return new self();
    }

    public function create(array $extra = []): Invoice
    {
        return Invoice::create(array_merge(
            [
                'number' => 'I-1',
                'status' => PendingInvoiceState::class,
                // ...
            ],
            $extra
        ));
    }
}
```

让我们讨论一些设计方案（design decisions）。

首先，是静态构造函数 `new`。你可能不太理解为什么需要这样一个函数，因为我们只是简单地把创建类的方法变成静态的。我将在本章后面深入回答这个问题，但是现在，你应该知道，在真正创建发票之前，我们希望这个工厂是高度可配置的。所以请放心，你很快就会明白的。

其次，为什么静态构造函数的名字是 `new`？实际是因为：在工厂的上下文中，`make` 和 `create` 往往与工厂实际产生的结果有关。使用 `new` 可以让我们避免不必要的混淆。

最后，关于 `create` 方法：它需要一个可选的额外数据数组，以确保我们可以随时在测试中做一些后置的更改（make some last-minute changes）。

通过一个简单例子，我们现在可以像这样创建发票：

```
public function test_case()
{
    $invoice = InvoiceFactory::new()->create();
}
```

在研究可配置性之前，让我们先解决一个我们可以立即进行的小改进：发票号码应该是唯一的，所以如果我们在一个测试案例中创建两张发票，就有可能会出现问题。我们不想在大多数情况下还要担心跟踪发票号码，所以让工厂来处理这些问题：

```
class InvoiceFactory
{
    private static int $number = 0;

    public function create(array $extra = []): Invoice
    {
        self::$number += 1;

        return Invoice::create(array_merge(
            [
                'number' => 'I-' . self::$number,
                // ...
            ],
            $extra
        ));
    }
}
```

## 工厂嵌套（Factories in factories）

在最初的 Laravel 工厂的例子中，我展示了我们可能想用工厂的状态来创建一张付费发票。我之前天真的认为这只是意味着改变发票模型上的状态字段。我们还需要在数据库中保存一个实际支付（actual payment）！

Laravel 默认的工厂可以通过回调来处理这个问题，这些回调会在模型被创建后触发，但是想象一下，如果你要管理几个甚至几十个状态，每个状态都有它们的副作用，那将会发生什么。一个简单的 `$factory->afterCreating` 钩子并不足以以一种合理的方式来管理这些状态。

所以，我们反过来做。我们在实际创建发票之前，正确地配置工厂。

```
class InvoiceFactory
{
    private ?string $status = null;

    public function create(array $extra = []): Invoice
    {
        $invoice = Invoice::create(array_merge(
            [
                'status' => $this->status ?? PendingInvoiceState::class
            ],
            $extra
        ));

        if ($invoice->status->isPaid()) {
            PaymentFactory::new()->forInvoice($invoice)->create();
        }

        return $invoice;
    }

    public function paid(): self
    {
        $clone = clone $this;

        $clone->status = PaidInvoiceState::class;

        return $clone;
    }
}
```

如果你想知道那个 `clone` 的作用，我们回头再讲。

我们所做的事情就是把发票的状态变成可配置的，就像 Laravel 的工厂状态一样，但在我们的例子中，有一个好处是我们的 IDE 知道我们正在处理什么：

```
public function test_case()
{
    $invoice = InvoiceFactory::new()
        ->paid()
        ->create();
}
```

不过，我们仍有改进的余地。你看到我们在发票创建后做了检查吗？

```
if ($invoice->status->isPaid()) {
    PaymentFactory::new()->forInvoice($invoice)->create();
}
```

这还可以做得更灵活。我们在下面使用一个 `PaymentFactory`，但如果我们想对付款方式进行更精细的控制呢？例如，你可以想象有一些关于已付发票的业务规则，根据付款类型的不同会有不同的行为（behave）。

我们也想避免直接向 `InvoiceFactory` 传递太多的配置，因为它很快就会变得一团糟。那么，我们如何解决这个问题呢？

答案是：我们允许开发者有选择地将一个 `PaymentFactory` 传递给 `InvoiceFactory`，这样开发者就可以在 `InvoiceFactory` 之外随意配置这个工厂了。它看起来像这样：

```
public function paid(PaymentFactory $paymentFactory = null): self
{
    $clone = clone $this;

    $clone->status = PaidInvoiceState::class;
    $clone->paymentFactory = $paymentFactory ?? PaymentFactory::new();

    return $clone;
}
```

以及它在 `create` 方法中如何使用：

```
if ($this->paymentFactory) {
    $this->paymentFactory->forInvoice($invoice)->create();
}
```

通过这样做，让我们有了更多的可能。在这个例子中，我们正在制作一张已付款的发票，并且特定是用 Visa 付款的发票。

```
public function test_case()
{
    $invoice = InvoiceFactory::new()
        ->paid(
            PaymentFactory::new()->type(VisaPaymentType::class)
        )
        ->create();
}
```

下面是另一个例子：我们想测试一下，当发票过期后、付款超时，如何处理发票：

```
public function test_case()
{
    $invoice = InvoiceFactory::new()
        ->expiresAt('2020-01-01')
        ->paid(
            PaymentFactory::new()->padiAt('2020-05-20') )
        ->create();
}
```

仅仅几行代码，就给我们带来了极大的灵活性。


## 不可变工厂（Immutable factories）

现在，再来想想刚刚的 `clone` 是干嘛的？为什么要让工厂不可改变？你看，有时你想用相同的测试案例制作几个模型，但有一些细微的差别。不必为每个模型创建一个新的工厂对象，你可以重新使用原来的工厂对象，只改变你需要的东西。

如果你不使用不可变工厂，你可能会得到不是你想要的数据。以发票付款为例：比如我们需要两张在同一日期的发票，一张已付，一张待付。

```
$invoiceFactory = InvoiceFactory::new()
    ->expiresAt(Carbon::make('2020-01-01'));

$invoiceA = $invoiceFactory->paid()->create();
$invoiceB = $invoiceFactory->create();
```

如果我们的付款方法不是不可变的，那就意味着 `$invoiceB` 也会是一张已付款的发票！我们可以对每一个模型的创建进行精细管理，但这就失去了这种模式的灵活性。这就是不可变函数的好处：你可以建立一个基础工厂，并在你的测试中重复使用它，而不用担心意外的副作用。

有了这两个原则：在工厂内配置工厂，并使其不可变，就有了许多可能性。当然，编写这些工厂需要一些时间，但它们在整个开发过程中也节省了很多时间。根据我的经验，写这些工厂的开销是非常值得的，因为带来的收益远远高于它们的成本。

自从使用这个模式后，我就再也没有用 Laravel 内置的工厂了。这种方法有太多的好处了。

我能想到的一个缺点是，你需要一些额外的代码来同时创建几个模型。但是如果你愿意的话，你可以很容易地在一个基础工厂类中添加一小段代码，比如这样：

```
abstract class Factory
{
    // 具体的工厂应该有个返回类型
    abstract public function create(array $extra = []);

    public function times(int $times, array $extra = []): Collection
    {
        return collect()
            ->times($times)
            ->map(fn() => $this->create($extra));
    }
}
```

另外，请记住，你也可以将这些工厂用在其他地方，而不仅仅是模型。你可以广泛地使用它们来设置 DTO，甚至是请求类。

因此，现在让我们看看实践中的测试，你会看到我们的工厂大放异彩。


# 测试 DTO（Testing DTOs）

我将展示如何测试我们在前几章中讨论的所有模式的例子，我将从 DTO 开始，因为它们是最简单的：你根本不需要测试它们。

所以，我再次重申一下：DTO 的优点在于它们是强类型的 —— 至少是 PHP 允许的强类型。这就是它们的唯一目的：表示数据（representing data）。我在第二章中已经解释过，强类型系统与静态分析相结合可以防止一系列运行时的错误。

因此，只要我们的 DTO 只做这个事情 —— 以强类型的方式表示数据 —— 那么就没有什么好测试的。

当然，还有 DTO 和输入数据之间的映射：你需要手动映射数据，例如，从一个请求到 DTO。你可能还记得，这也是我们在第二章中讨论过的。现在，如果你决定使用 DTO 本身的内置静态构造函数，那么还是需要编写一些测试，专门用来测试输入数据和 DTO 之间的映射是否正确。

下面是一个这样的测试例子：

```
/** @test */
public function form_booking_store_request()
{
    $unit = UnitFactory::new()->create();

    $dto = BookingData::fromStoreRequest(new BookingStoreRequest([
        'name' => 'test',
        'unit_id' => $unit->id,
        'date_start' => '2020-12-01',
        'date_end' => '2020-12-05',
    ]));

    $this->assertInstanceOf(BookingData::class, $dto);
}
```

首先，我们使用我们乐意的方式来断言（assert），如我们所期望的那样工作 —— 你可以看到我们使用一个 `UnitFactory` 来帮助设置一些数据并保持测试的简洁。

所以我们实例化一个 DTO 对象，然后断言它是否真的是 `BookingData` 类的一个对象。我们真的不需要做其他的断言，类型检查涵盖了其他一切。

接下来我们可以测试异常，例如，当 `unit_id` 没有被传递时：应该抛出一个 `ModelNotFoundException`：

```
/** @test */
public function from_booking_store_request_without_unit_fails()
{
    $this->expectException(ModelNotFoundException::class);

    BookingData::fromStoreRequest(new BookingStoreRequest([
        'name' => 'test',
        'date_start' => '2020-12-01',
        'date_end' => '2020-12-05',
    ]));
}
```

所以说真的，DTO 测试非常简单，没有什么好说的了。让我们继续进行下一个测试。

## 测试动作（Testing actions）


