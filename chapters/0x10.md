# 视图模型（View models）

It's time to take a first deep dive into the application layer. One of the core ideas in this book is to keep code clean, concise and manageable. This chapter won't be any different, as we'll look at how to keep controllers clean and to-the-point.

The pattern we'll use to help us is called the view model pattern. As its name suggests, these classes are models to your view files; they are responsible for providing data to a view, which would otherwise come directly from the controller or the domain model. In addition, they allow a better separation of concerns, and provide more flexibility for the developer.

In essence, view models are simple classes that take data and transform it into something usable for the view. In this chapter I'll show you the basic principles of the pattern, we'll take a look at how they integrate in Laravel projects, and finally I'll show you how we use the pattern in one of our projects.

Let's start with a simplified example. Say you have a form which creates a blog post with a category. You'll need a way to fill the select box in the view with category options and the controller has to provide those.

```
public function create()
{
    return view('blog.form', [
        'categories' => Category::all(),
    ]);
}
```

The above example works for the create method, but let's not forget we should also be able to edit existing posts.

```
public function edit(Post $post)
{
    return view('blog.form', [
        'post' => $post,
        'categories' => Category::all(),
    ]);
}
```

Next there's a new business requirement: users should be restricted as to which categories they are allowed to post in. In other words, the category selection should be restricted based on the user.

```
return view('blog.form', [
    'categories' => Category::allowedForUser(
        current_user()
    )->get(),
]);
```

Unfortunately, however, this approach doesn't scale because to begin with, you'll have to change code both in the create and edit method. Then, can you imagine what happens when you need to add tags to a post? Or if there's another special admin form for creating and editing posts?

The next solution is to have the post model itself provide the categories, like so:

```
class Post extends Model
{
    public static function allowedCategories(): Collection
    {
        return Category::query()
            ->allowedForUser(current_user())
            ->get();
    }
}
```

There are numerous reasons why this is a bad idea, though I've seen this approach used often in Laravel projects. Let's focus on the most relevant problem for our case: it still allows for duplication.

Say there's another model News which also needs the same category selection. This causes duplication, but on the model level instead of in the controllers.

Another option is to put the allowedCategories method on the User model. This makes the most sense, but also makes maintenance harder. For example, imagine we're using tags as mentioned before; they don't rely on the user but now we need to get the categories from the user model, and tags from somewhere else.

I hope it's clear that using models as data providers for views isn't a scalable solution. Wherever you try to get the categories from, there always seems to be some code duplication which makes it harder to maintain and reason about the code.

This is where view models come into play because they encapsulate all this logic so that it can be reused in different places. Critically, they have one responsibility and one responsibility only: providing the view with the correct data.

```
class PostFormViewModel
{
    // ...

    public function __construct(User $user, Post $post = null)
    {
        $this->user = $user;
        $this->post = $post;
    }

    public function post(): Post
    {
        return $this->post ?? new Post();
    }

    public function categories(): Collection
    {
        return Category::allowedForUser($this->user)->get();
    }
}
```

Let's name a few key features of such a class:

- All dependencies are injected which gives the most flexibility to the outside context.
- The view model exposes some methods that can be used by the view.
- There will either be a new or existing post provided by the post method, depending on whether you are creating or editing a post.

This is what the controller looks like:

```
class PostsController
{
    public function create()
    {
        $viewModel = new PostFormViewModel(
            current_user()
        );

        return view('blog.form', compact('viewModel'));
    }

    public function edit(Post $post)
    {
        $viewModel = new PostFormViewModel(
            current_user(),
            $post
        );

        return view('blog.form', compact('viewModel'));
    }
}
```

And finally, it can be used in the view like so:

```
<input value="{{ $viewModel->post()->title }}" />
<input value="{{ $viewModel->post()->body }}" />

<select>
    @foreach($viewModel->categories() as $category)
        <option value="{{ $category->id }}">
            {{ $category->name }}
        </option>
    @endforeach
</select>
```

# View models in Laravel

The previous example showed a simple class as our view model. This is sufficient to use the pattern, but within Laravel projects there are a few more niceties we can add.

For example, you can pass a view model directly to the view function if the view model implements Arrayable.

```
public function create()
{
    $viewModel = new PostFormViewModel(
        current_user()
    );

    return view('blog.form', $viewModel);
}
```

The view can now directly use the view model's properties like $post and $categories. The previous example now looks like this:

```
<input value="{{ $post->title }}" />
<input value="{{ $post->body }}" />

<select>
    @foreach($categories as $category)
        <option value="{{ $category->id }}">
            {{ $category->name }}
        </option>
    @endforeach
</select>
```

You can also return the view model itself as JSON data, by implementing Responsable. This can be useful when you're saving the form via an AJAX call and want to repopulate it with up-to-date data after the call is done.

```
public function update(Request $request, Post $post)
{
    // Update the post...

    return new PostFormViewModel(
        current_user(),
        $post
    );
}
```

You might see a similarity between view models and Laravel resources. Remember that resources map one-to-one on a model, whereas view models may provide whatever data they want.

In some places, we're actually using resources and view models combined:

```
class PostViewModel
{
    // ...

    public function values(): array
    {
        return PostResource::make(
            $this->post ?? new Post()
        )->resolve();
    }
}
```

## View composers

You might be thinking there's some overlap with Laravel's view composers, but don't be mistaken. The Laravel documentation explains view composers like so:

> View composers are callbacks or class methods that are called when a view is rendered. If you have data that you want to be bound to a view each time that view is rendered, a view composer can help you organise that logic into a single location.

View composers are registered like this:

```
class ViewComposerServiceProvider extends ServiceProvider
{
    public function boot()
    {
        View::composer('profile', ProfileComposer::class);

        View::composer('dashboard', function ($view) {
            // ...
        });
    }

    // ...
}
```

As you can see, you can both use a class and a closure which you can use to add variables to a view.

Here's how view composers are used in controllers:

```
class ProfileController
{
    public function index()
    {
        return view('profile');
    }
}
```

Can you see them?

No, of course not: view composers are registered somewhere in the global state, and you don't know which variables are available to the view, without that implicit knowledge.

Now I know that this isn't a problem in small projects. When you're the only developer and have 20 controllers and maybe 20 view composers, it'll all fit in your head.

But what about the kind of projects we're writing about in this book? When you're working with several developers, in a codebase that counts thousands upon thousands of lines of code, it won't all fit in your head anymore — certainly not on that scale. What's more, we haven't even considered your colleagues and the difficulties they will face, individually and as a team!

That's why the view model pattern is, for these kinds of projects, the better approach. It makes clear from the controller itself what variables are available to the view, and on top of that, you can re-use the same view model for multiple contexts.

One last benefit — one you might not have thought about — is that we can pass data into the view model explicitly. If you want to use a route argument or bound model to determine data passed to the view, it is done explicitly.

In conclusion: managing global state is a pain in large applications, especially when you're working with multiple developers on the same project. Also remember that just because two solutions have the same end result, it doesn't mean that they are the same!

## 链接

- [目录](../README.md)
- 上一章：[进入应用层（Entering the application layer）](0x09.md)
- 下一章: [HTTP 查询（HTTP queries）](0x11.md)
