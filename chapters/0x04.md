# 模型（Models）

在前几章中，我已经谈到了应用程序的三个核心中的两个：`DTO` 和 `actions` —— 数据（data）和功能（functionality）。在这一章中，我将专注于我认为是核心的最后一块：输出持久化存储中的数据（exposing data that's persisted in a data store）；说人话：模型（models）。

现在，模型是一个棘手的问题。Laravel 在 `Eloquent` 模型类中提供了很多功能，这意味着它们不仅代表了数据存储中的数据，还允许你建立查询、加载和保存数据，还有一个内置的事件系统，等等。

在这一章中，我不是想让你抛弃 Laravel 提供的所有模型功能 —— 它确实很有用。然而，我将列出一些你需要注意的陷阱，以及解决这些问题的方法，这样即使在大型项目中，模型也不会导致难以维护。

我的观点是，我们应该拥抱框架，而不是试图对抗它。我们应该以一种可维护的方式来拥抱它。

## 模型 != 业务逻辑（Models ≠ business logic）

许多开发人员陷入的第一个陷阱是，他们认为模型是实现业务逻辑（business logic）的地方。我已经列举了一些内置 Laravel 模型的职责，我想说的是不要再往里加任何东西。

能够做到像 `$invoiceLine->price_including_vat` 或 `$invoice->total_price` 听起来很有吸引力；这确实可以做到。实际上，我也确实觉得发票（invoices）和发票项目（invoice lines）应该有这样的方法。但是有一个重点区别：这些方法不应该进行任何计算。让我们来看下不应该怎么做：

这是我们的发票模型（invoice model）上的 `total_price` 访问器（accessor），遍历所有的发票项目（invoice lines），加起来得出它们的总价。

```
class Invoice extends Model
{
    public function getTotalPriceAttribute(): int
    {
        return $this->invoiceLines
        ->reduce(
            fn (int $totalPrice, InvoiceLine $invoiceLine) =>
                $totalPrice + $invoiceLine->total_price,
            0
        );
    }
}
```

这是每个项目计算总价的方法：

```
class InvoiceLine extends Model
{
    public function getTotalPriceAttribute(): int
    {
        $vatCalculator = app(VatCalculator::class);

        $price = $this->item_amount * $this->item_price;

        if ($this->price_excluding_vat) {
            $price = $vatCalculator->totalPrice(
                $price,
                $this->vat_percentage
            );
        }

        return $price;
    }
}
```

既然你阅读了前一章关于动作（actions），你可能会猜到我会怎么做：计算一张发票的总价是一个用户故事（user story），应该由一个动作（action）来表示。

