# 动作（Actions）

现在我们可以以一种类型安全和透明的方式来处理数据，我们需要开始用它做一些事情。

就像我们不希望使用充满随机数据的数组一样，我们也不希望我们项目中最关键的部分，即业务功能，被分散在随机的函数和类中。

这里有一个例子：你项目中的一个场景（stories）可能是『管理员创建发票（an admin to create an invoice）』。这意味着我们将在数据库中保存一张发票，但要做的事情不止这些。

单独计算发票每个项目的价格和总价格

- 生成发票编号（Generate an invoice number）
- 保存发票信息到数据库（Save the invoice to the database）
- 通过支付提供者创建一笔支付（Create a payment via the payment provider）
- 创建包含所有相关信息的 PDF（Create a PDF with all relevant information）
- 将 PDF 发送给客户（Send this PDF to the customer）

在 Laravel 中一个常见的做法是创建『胖模型（fat models）』来处理所有这些功能。在这一章中, 我们将探讨另一种方法来将这种行为添加到我们的代码库中。

我们将把这些用户故事（user stories）作为项目的一等公民，而不是把功能混入模型（models）或控制器（controllers）中。我倾向于将这些称为『动作（actions）』。

## 术语（Terminology）

在研究它们如何使用之前，我们需要讨论动作（actions）是如何构成的。首先，它们存在领域层中。

其次，它们是没有任何抽象或接口的简单类。一个 `Action` 是一个接受输入，做一些事情，并给出输出的类。这就是为什么一个 `Action` 通常只有一个公开方法，有时还包含一个构造函数。

作为我们项目中的一个惯例，我们决定对所有的类添加后缀。当然，`CreateInvoice` 听起来不错，但当你要处理几百或几千个类时，你要确保不会发生命名冲突。你看，`CreateInvoice` 很可能也是一个可调用的控制器（invokable controller）、一个命令（command）、一个任务（job）或一个请求（request）的名字。我们希望尽可能地消除混淆，因此，`CreateInvoiceAction` 是比较好的名字。

显然，这意味着类的名称变得更长。实际情况是，如果你在做较大的项目，你无法避免使用较长的名字，以确保没有混淆的可能。下面是我们一个项目中的极端例子（我没有开玩笑）：`CreateOrUpdateHabitantContractUnitPackageAction`

我们一开始很讨厌这个名字。我们拼命地想出一个更短的名字。但最后，我们不得不承认，明确一个类的内容是最重要的事情。反正我们的 IDE 的自动补全功能会弱化长名字带来的不便。

当我们确定了类的名称后，要克服的下一个障碍是为使用我们的动作（actions）的公共方法命名。一种选择是让它成为可调用的（invokable），就像这样：

```
class CreateInvoiceAction
{
    public function __invoke(InvoiceData $invoiceData): Invoice
    {
        // ...
    }
}
```

但这种方法实际上有一个问题。为了理解这个问题，我需要提到一些我们在后面章节会看到的东西，那就是有时候，我们会组合使用其他动作（actions）。它看起来就像这样：

```
class CreateInvoiceAction
{
    private CreateInvoiceLineAction $createInvoiceLineAction;

    public function __construct(
        CreateInvoiceLineAction $createInvoiceLineAction
    ) { /* ... */ }

    public function __invoke(InvoiceData $invoiceData): Invoice
    {
        foreach ($invoiceData->lines as $lineData) {
            $invoice->addLine(
                 ($this->createInvoiceLineAction)($lineData)
            );
        }
    }
}
```

看到问题了吗？PHP 不允许直接调用一个类上的可调用（invokable property）的属性，因为它会寻找一个类的方法（method）。这就是为什么你必须在调用该 `Action` 之前用括号把它包起来。

如果你不想使用这种古怪的语法, 还有其他的选择: 例如, 我们可以使用 `handle`，Laravel 经常在这种情况下使用它作为默认名称。这又是一个问题，特别是 Laravel 使用它。

每当 Laravel 允许你使用句柄，例如，作业（jobs）或命令（commands），它也会提供依赖注入。在我们的动作（actions）中，我们只希望构造函数有依赖注入的功能。我们将在本章的后面仔细研究这背后的原因。

所以 `handle` 也被淘汰了。当我们开始使用动作（actions）时，我们实际上对这个命名难题进行了很多思考。最后我们决定采用 `execute`。但请记住，你可以自由地想出你自己的命名规则，因为这里的重点是关于使用动作（actions）的模式，而不是它们怎么命名。


# 实践（Into practice）

