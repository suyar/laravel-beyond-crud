# HTTP 查询（HTTP queries）

In the previous chapter, we covered a very common use case in our applications and provided a pattern to handle it: view models will make sure all data needed by a view is provided in the right form.

There's another everyday use case in large applications: overviews showing collections of data that need to be filtered, paginated, sorted, and searched — also known as data tables.

Whether you're doing full-page refreshes or use AJAX, at scale, you'll always need to ask the server for an updated set of data, based on given conditions. A common practice is to send these conditions via query parameters, read them, and adjust the SQL query accordingly.

I realise there's ambiguity here: there are the HTTP query parameters, and there's the SQL query. Since both are called query it can cause quite a bit of confusion. For example, this chapter will focus on query builders. That is, not the Eloquent model query builders we talked about earlier, but rather classes that will handle the mapping between query parameters and the actual SQL query.

You can see the use of “query” can become unclear rather fast, so I'll try my best to make it as transparent as possible about which kind of "query" I'm referring to.

So, let me tell you upfront that we have a package that takes care of the boring stuff, it's called spatie/laravel-query-builder. The mapping between HTTP query parameter values and the model query conditions is done behind the scenes. As you can imagine, there's no rocket science going on over there - we're mapping values from one side to the other.

What's interesting though, is how our package can be used in large projects. Imagine an admin page that shows an overview of all invoices with a few sorts and filters. The default approach with the query builder package would be to do something like this:

```
class InvoicesController
{
    public function index()
    {
        $invoices = QueryBuilder::for(Invoice::class)
            ->allowedFilters(
                'number',
                'client',
            )
            ->allowedSorts(
                'number',
            )
            ->get();

        // ...
    }
}
```

Here we've configured the query builder to only look for specific HTTP query parameters: filter[number]=, filter[client]= and sort=number. All other query parameters will be ignored. This approach works fine in smaller projects, but in large projects, you're generally dealing with more complex model queries. These queries often have to be shared (albeit with small differences) between several controllers.

It sounds like a good case for extracting these kinds of query builders to their own classes, instead of configuring them on the fly in the controller.

For example, we could make a class called InvoiceIndexQuery, and it would look something like this:

```
namespace App\Admin\Invoices\Queries;

use Spatie\QueryBuilder\QueryBuilder;

class InvoiceIndexQuery extends QueryBuilder
{
public function __construct(Request $request)
    {
        $query = Invoice::query()
            ->with([
                'invoicee.contact',
                'invoiceLines.article',
            ]);

        parent::__construct($query, $request);

        $this
            ->allowedFilters(
                'number',
                'client',
            )
            ->allowedSorts(
                'number',
            );
    }
}
```

Because we're extending Spatie\QueryBuilder\QueryBuilder, we'll need to call the parent constructor. It requires two things: the request, to read the HTTP query parameters from, and the actual model query we're going to modify.

Two interesting things are going on: first of all, we're injecting the request. Since it's already registered in the container by default, we can rely on autowiring to resolve it, but you'll see that later. Second: we're modifying our base query to load some relations eagerly.

It’s interesting because you can do whatever you want with the base query before passing it to the parent constructor. You could also, for example, join other tables to allow for more complex filtering:

```
// ...

use Spatie\QueryBuilder\AllowedFilter;
use Support\QueryBuilder\FuzzyFilter;

class InvoiceIndexQuery extends QueryBuilder
{
    public function __construct(Request $request)
    {
        $query = Invoice::query()
            ->join('invoicees', 'invoicees.invoice_id', '=', 'invoices.id')
            ->join('contacts', 'invoicees.contact_id', '=', 'contacts.id');

        parent::__construct($query, $request);

        $this
            ->allowedFilters(
                // ...

                AllowedFilter::custom(
                    'search',
                    new FuzzyFilter(
                        'contacts.number',
                    )
                )
            );
    }
}
```

Most importantly, using this approach gets you proper static analysis on the base query, which is, as you know, a valuable asset in large code bases.

However, there's another thing I like about this approach, besides proper static analysis: separated query classes keep the controllers clean! Because we're relying on the request to be injected, we can inject the query builder class directly in our controller methods, like so:

```
class InvoicesController
{
    public function index(InvoiceIndexQuery $invoiceQuery)
    {
        $invoices = $invoiceQuery->get();
        // ...
    }
}
```

Of course, you could also inject the query builder in the view model, and handle everything from there.

Once more, using these dedicated query builder classes keeps our controllers clean and allows for reusability.

Also note that every eloquent method you're used to is available in our custom query class. That means you could add some last-minute, controllerspecific changes to your query builder, on the fly. For example, take a PaidInvoicesController, which should only show the paid invoices.

```
class PaidInvoicesController
{
    public function index(InvoiceIndexQuery $invoiceQuery)
    {
        $invoices = $invoiceQuery
            ->whereStatus(InvoiceStatus::PAID())
            ->get();

        // ...
    }
}
```

You can imagine the flexibility: you don't have to specify the filters, sorting, eager loads, etc. over and over again, yet you can still make very specific changes to the query builder for specific cases, in the controller.

There's a lot more to tell about query builders, and you can read all about them in their docs. You can find the relevant links in the footnotes chapter if you want to check them out!

## 链接

- [目录](../README.md)
- 上一章：[视图模型（View models）](0x10.md)
- 下一章: [作业（Jobs）](0x12.md)
