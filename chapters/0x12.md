# 作业（Jobs）

There's one important concept of the application layer that I haven't mentioned yet: jobs. Why do I consider them to be part of the application layer and not domain code? After all, the Laravel docs clearly describes jobs as the place to be when you're trying to execute asynchronous business logic.

I want to answer that question in this chapter.

See, the way I think of jobs and their responsibility is to execute code on a bus, a pipeline where jobs come in, and are handled in sequence. Now, that doesn't have to be an asynchronous pipeline per se, but in practice and production, this will most likely be the case.

And let me just say as a sidenote how thankful we should be with the infrastructure Laravel provides out of the box and how we're completely free to manage those jobs: it's as easy as dispatching a class, and Horizon is a great piece of software that scales really well.

Anyways, back to why jobs belong in the application layer. I think of their responsibility as managing that pipeline workflow. They are classes that are responsible for: configuring whether they are queueable, how many of them can be run simultaneously, if their execution should be delayed, if they should be chained, etc.

In a way, jobs have lots of similarities to controllers:

- They receive input: controllers from the request and jobs specified by the developer (most of the time serialised).
- They are dispatched to process that input: controllers during an HTTP request, jobs mostly on an asynchronous queue.
- They both support middleware to add functionality before and after the actual processing.
- And finally their end result is some kind of output: controllers via HTTP responses, jobs by writing something to the database, sending mails, and of course, much more.

And just like controllers, we want to avoid adding too much functionality in them. This whole book has been about moving code to small classes, each with their own responsibility and all of them easy to comprehend and testable.

So let's not make jobs the exception: let them have their responsibility of managing that queue, and handle the actual business logic just like we did with controllers, by using domain actions. Jobs are just another way of exposing business functionality to the outside world.

And that's why jobs themselves, just like controllers, belong in the application layer.

## Simple action jobs

There are cases, probably even many, where a job's task is simply to execute an action. These jobs often look very simple and similar, something like this:

```
class SendInvoiceMailJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    private Invoice $invoice;

    public function __construct(Invoice $invoice)
    {
        $this->invoice = $invoice;
    }

    public function handle(
        SendInvoiceMailAction $sendInvoiceMailAction
    ): void {
        $sendInvoiceMailAction->execute($this->invoice);
    }
}
```

And I briefly want to mention that “sending an invoice mail” could very well be important business functionality. There's more to it than just sending the mail: you also want to keep track of which user received which mails; you might need to send extra attachments with it, depending on the type of client; and you can probably think of a few other use cases. That's just to say that indeed, "sending a mail" is domain code.

Anyway, you often end up with these kinds of jobs: one line, executing the action. Moreover, that often feels like an overhead because this is rather boring code, and writing such a class for tens, if not hundreds of actions, doesn't feel all that great.

We felt this pain ourselves when we started using this approach, so naturally we wanted a solution. What we came up with was something that probably isn't the biggest surprise: one job that's able to handle all actions. We added a little syntactical sugar on top of it so that dispatching such a job could be done via the action itself, whilst maintaining static analysis of course.

Here's what the original way of dispatching the above job would look like:

```
dispatch(new SendInvoiceMailJob($invoice));
```

And here's what our solution looks like:

```
$sendInvoiceMailAction
    ->onQueue()
    ->execute($invoice);
```

Calling onQueue on the action will make an action job under the hood, and dispatch it when calling execute. Keep in mind that your IDE can still properly autocomplete the execute. There's a little bit of magic involved, and if you're interested you can check it out since this functionality is a package on its own: it's called spatie/laravel-queueable-action.

So in summary: jobs do belong in the application layer, since business functionality shouldn't be directly handled by them. This doesn't mean we need a dedicated job class for simple actions though. With the right abstractions, we can skip all that boilerplate code.

## 链接

- [目录](../README.md)
- 上一章：[HTTP 查询（HTTP queries）](0x11.md)
- 下一章: [写在最后（In closing）](0x13.md)
