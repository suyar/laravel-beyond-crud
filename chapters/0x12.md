# 作业（Jobs）

应用层有一个重要的概念我还没有提到：作业。为什么我认为它们是应用程序层的一部分，而不是领域代码？毕竟，Laravel 文档清楚地将作业描述为尝试执行异步业务逻辑的地方。

我想在本章中回答这个问题。

看，我认为作业和它们的职责是在总线（bus）上执行代码，总线是作业进入的管道（pipeline），并按顺序处理。现在，这原本就不一定是一个异步管道（asynchronous pipeline），但在实践和生产中，这将是最有可能的情况。

让我顺便说一下，我们应该非常感谢 Laravel 提供的开箱即用的基础设施（infrastructure），以及我们可以完全自由地管理这些作业：简单的调度（dispatching）一个类，还有 Horizon 是一个伟大的软件，它扩展的非常好。

总之，回到为什么作业属于应用层的问题上。我认为他们的职责是管理管道工作流。这些类的职责是：配置它们是否可队列化，它们中可以同时运行多少个，它们的执行是否应该被推迟，它们是否应该使用作业链，等等。

在某种程度上，作业与控制器有很多相似之处：

- 它们接收输入：控制器的输入来自请求，作业的输入由开发者指定（大多数时候是序列化的数据）。
- 它们被调度去处理该输入：控制器是在 HTTP 请求期间被调用，作业主要在一个异步队列中。
- 它们都支持中间件，以便在实际处理之前和之后增加功能。
- 最后，他们的最终结果是某种输出：控制器通过 HTTP 响应，作业通过向数据库写东西，发送邮件，当然，还有更多。

就像控制器一样，我们要避免在其中添加太多的功能。这本书的内容就是将代码转移到小类中，每个小类都有自己的职责，而且都是易于理解和测试的。

所以我们不要让作业成为例外：让它们承担管理队列的职责，并通过使用领域操作来处理实际的业务逻辑，就像我们对待控制器一样。作业只是将业务功能暴露给外界的另一种方式。

这就是为什么作业本身，就像控制器一样，属于应用层。

## 简单作业（Simple action jobs）

有些情况下，甚至可能有很多情况下，一个作业的任务只是执行一个 `action`。这些工作通常看起来非常简单和相似，像这样：

```
class SendInvoiceMailJob implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    private Invoice $invoice;

    public function __construct(Invoice $invoice)
    {
        $this->invoice = $invoice;
    }

    public function handle(
        SendInvoiceMailAction $sendInvoiceMailAction
    ): void {
        $sendInvoiceMailAction->execute($this->invoice);
    }
}
```

我想简单提一下，『发送发票邮件』很可能是很重要的业务功能。它不仅仅是发送邮件：你还想跟踪哪个用户收到了哪些邮件；你可能需要同时发送额外的附件，这取决于客户端的类型（depending on the type of client）；你可能还能想到其他一些场景。这里只是想说明『发送邮件』是领域代码。

总之，你经常会有这样的作业：只有一行，执行 Action。此外，这常常让人感觉是一种开销，因为这是相当无聊的代码，为几十个，就算不没有几百个的 Action 写这样一个类，感觉并不是那么好。

当我们开始使用这种方法时，我们自己也感受到了这种痛苦，所以我们自然而然地想要一个解决方案。我们想出的办法并没非常的新颖：一个作业能够处理所有 Action。我们在其之上添加了一些语法糖，以便可以通过动作本身来调度这样的工作，同时保持静态分析。

以下是调度上述作业的原始方式：

```
dispatch(new SendInvoiceMailJob($invoice));
```

这就是我们的解决方案的模样：

```
$sendInvoiceMailAction
    ->onQueue()
    ->execute($invoice);
```

在 Action 上调用 `onQueue` 将隐式的产生一个 Action 作业，并在调用 `execute` 时调度（dispatch）。请记住，你的 IDE 仍然可以正确地自动补全 `execute`。这里面有一个神器的东西，如果你有兴趣，可以去看看，这个功能有一个独立的包：它叫做 `spatie/laravel-queueable-action`。

综上所述：作业确实属于应用层，因为业务功能不应该由它们直接处理。但这并不意味着我们需要一个专门的作业类来处理简单的 Action。有了正确的抽象，我们可以跳过所有这些模板代码（boilerplate code）。

## 链接

- [目录](../README.md)
- 上一章：[HTTP 查询（HTTP queries）](0x11.md)
- 下一章: [尾言（In closing）](in-closing.md)
