# 数据的使用（Working with data）

我使用领域对代码进行分组的思想 —— 我在上一章中解释过 —— 作为我们用来构建的基本理念。你会注意到在本书的前面部分中，这个核心思想会反复地出现。


早期，我们将以此为基础，再次展示出它的简单与强大：我们将使用结构化的方式对其建模；我们将使数据成为我们编码的一等公民。

在每个项目的开始，你几乎都会注意到数据建模的重要性：你一般不会从控制器（controllers）和作业（jobs）开始写代码，而是从 Laravel 的模型（models）开始。在大型项目中制作 `ERD` 和其他类型的图标，可以协助概念化应用程序要处理的数据。只有这些明确了，你才可以构建使用数据的入口（entry points）和钩子（hooks）。

本章的目的是告诉你数据流的重要性。我们甚至都不去讨论模型（models）。相反，我们将从单纯的数据入手，目的是让你团队中的所有开发人员都能写出可预测、安全且能与这些数据交互的代码。


为了能真正体会到应用一个简单的面向数据的模式所带来的所有好处，我们需要先深入了解一下 PHP 的类型系统。

## 类型理论

不是所有人对类型系统的术语理解都一样。因此，我们先明确几个术语。


类型的强度 —— 强类型或弱类型 —— 定义了一个变量在被定义后是否可以改变其类型。一个简单的例子：给定一个字符串变量 `$a = 'test'`；一个弱类型系统允许你将该变量重新分配到另一个类型，例如 `$a = 1`，变成一个整数。

PHP 是一种弱类型的语言。让我们来看看这在实践中意味着什么。

```
$id = '1'; // 例如，id 是从 url 参数获取的

function find(int $id): Model
{
    // 传进来的字符串 '1' 将被自动转换为 int 类型
}
find($id);
```

说白了：PHP 属于弱类型系统也是有意义的。作为一种主要使用 HTTP 请求的语言，所有东西基本上都是一个字符串。

你可能认为在高版本的 PHP 中，通过使用严格类型模式（strict types），可以避免这种隐式的类型切换，但这并不完全正确。

声明严格类型可以防止将其他类型传递给函数，但您仍然可以在函数本身中更改变量的值。

```
declare(strict_types=1);

function find(int $id): Model
{
    $id = '' . $id;

    /*
    * 这在 PHP 中是允许的
    * 现在， `$id` 变成了字符串
    */

    // ...
}

find('1'); // 会抛出错误

find(1); // 没问题
```

即使有严格的类型和类型提示，PHP 的类型系统也很弱。类型提示只能确保一个变量在该时间点的类型，而不能保证该变量未来可能被赋予的任何值。

